## #rules access rules

In the following description, "user" means "user or a [group][groups] that
he/she is a member of", and "repo" means "repo, or a group that it is a member
of, or a ([wild][] repo) pattern that matches it, or a group that contains a
pattern that matches it".

### what do rules look like

Here's an example ruleset.

    @staff          =   dilbert alice wally bob

    repo foo
        RW+         =   dilbert     # line 1
        RW+ dev     =   alice       # line 2
        -           =   wally       # line 3
        RW  temp/   =   @staff      # line 4
        R           =   ashok       # line 5

A rule line has the structure

    <permission> <zero or more refexes> = <one or more users/user groups>

The most commonly used permissions are:

  * R, for read only
  * RW, for push existing ref or create new ref
  * RW+, for  "push -f" or ref deletion allowed (i.e., destroy
    information)
  * `-` (the minus sign), to **deny** access.

There are also other, less commonly used, [types of permissions][write-types].

A [refex][] is an expression that matches the ref (i.e., branch or tag) being
pushed.

<font color="gray">You can also use [virtual refs][vref] to perform extra
checks and controls that you can't do with just the normal ref (like
refs/heads/master) being pushed.  The most common example is restricting
pushes by dir/file name, but there are lots of other possibilities.</font>

### how are the rules checked

Note that gitolite first [accumulates the rules][rule-accum] before checking
access.

#### read access -- clone, fetch, archive

Read access is checked once, just before passing control to git-upload-pack or
git-archive-pack.  At this point gitolite only knows the repo name, the user
name, and the fact that it is a read operation.

If the set of rules for this user on this repo has at least one rule where the
permission field contains an "R", access is granted.  If there are none,
access is denied.

The [refex][] field is ignored for this check.  (Git does not allow
distinguishing one ref from another for access control during read
operations).

Deny rules (the "-" permission) are ignored for this check.  In our example,
line 3 does not prevent wally from cloning the repo, because line 4 permits
it.  (This is the default behaviour.  You can change that by using the
[deny-rules][] option).

#### write access -- push

Write access is checked twice, once before passing control to
git-receive-pack, and once from within the update hook.

The **first check** is identical to the one for read access, except of course
the permission field must contain a "W".  As before, deny rules are ignored,
(line 3 does not prevent wally from trying to push because line 4 allows it),
and you can override that using the [deny-rules][] option.

The [refex][] field is ignored for this check, because at this point we don't
know what refs are going to be pushed.

The **second check** happens from within the update hook.  This check is much
more complex because deny rules are considered, which in turn means the
*sequence* of the rules makes a difference now.

Also, this time, git supplies us with three more pieces of information: the
name of the ref being updated (like "refs/heads/master"), the old SHA, and the
new SHA.  This information is sufficient to determine whether this is a normal
push or a forced, (a.k.a rewind), push.  A normal push requires the permission
field to contain a "W", while a forced push requires it to contain a "+".

Here's how the actual rule matching happens:

  * all the rules for this user and this repo are [collected][rule-accum] and
    examined *in the sequence* they appear in the conf file

  * for each rule:

      * If the ref does not match the [refex][], the rule is skipped.
      * If it's a deny rule, access is denied and the matching stops.
      * If the permission field matches the specific [type of
        write][write-types] operation, access is allowed and the matching
        stops.

  * If no rule ends with a decision, ("fallthru"), access is denied.

Now all you need is to understand how [refex][] matching happens and how the
permissions match the various [types of write operations][write-types].

### #permsum summary of permissions

The full set of permissions, in regex syntax, is `-|R|RW+?C?D?M?`.  This
expands to one of `-`, `R`, `RW`, `RW+`, `RWC`, `RW+C`, `RWD`, `RW+D`, `RWCD`,
or `RW+CD`, all but the first two optionally followed by an `M`.  And by now
you know what they all mean.

## additional topics

### #rule-accum rule accumulation

Gitolite was meant to collect rules from multiple places and apply them all.
For example:

    # we have 3 specifically named FOSS projects, but we also consider any
    # project in the foss/ directory to be FOSS.
    @FOSS-projects  =   git gitolite linux foss/..*

    # similarly for proprietary projects
    @prop-projects  =   foo bar baz prop/..*

    # our users are divided into staff, interns, and bosses
    @staff          =   alice dilbert wally
    @interns        =   ashok
    @bosses         =   PHB

    # we have certain policies.  The first is that FOSS projects are readable
    # by everyone
    repo @FOSS-projects
        R   =   @all

    # the second is that bosses can read any repo if they wish to
    repo @all
        R   =   @bosses

    # now we have specific rules for specific projects
    repo git
        ...some rules...

    ...etc...

As you can see, for each user+repo combination, several rules will apply.
Gitolite combines them all into one list (in the sequence they are found in
the conf file), before applying the access checks.

This extends to patterns also.  For example, if you have this:

    repo foss/apache
        ...some rules...

then, because this repo fits the pattern `foss/..*`, it is considered part of
the @FOSS-projects group, so all the rules that apply to that group are in
play when someone accesses foss/apache.

This is what we meant by "repo, or a group that it is a member of, or a
([wild][] repo) pattern that matches it, or a group that contains a pattern
that matches it", up at the top of this document.

### #deny-rules applying deny rules during the first check

The access rules above show that you cannot make an exception to a group for
the first check, i.e., you cannot lock Wally out of read access that other
members of @staff have.

Here's another situation.  Let's say you have this at the end of your
gitolite.conf file:

    repo @all
        R   =   gitweb daemon

but you don't want the gitolite-admin repo showing up on gitweb.  This is the
same situation -- you want to make an exception in '@all' this time.

Here's how to do that:

    repo gitolite-admin
        -   =   gitweb daemon
        option deny-rules = 1

    repo @all
        R   =   gitweb daemon

When you set the 'deny-rules' option for a repo, you're telling the pre-git
checks (i.e., the read access check and the first write access check), to pay
attention to the deny rules, which otherwise they ignore.

Note that, any time deny rules are in play, the order matters; the `-` rule
must come *before* the `R` rule.  Also, as a reminder, refexes are ignored for
the first check.
